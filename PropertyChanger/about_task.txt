
Есть достаточно большое количество классов с примерно одинаковым набором свойств

class Foo{
	public float Pr0{get;set;}
	public float Pr1{get;set;}
	...
	public float PrN{get;set;}
}

Значение некоторых свойств вычисляются по формулам.
Pr7 = (Pr4 - Pr2) * 9 / Pr1;
Pr1 = Pr5 + 1;
Все параметры в рамках одного класса.
Циклических зависимостей нет.

Задача: 
1. Необходимо обеспечить пересчет значений при изменении любого свойства входящего в 
зависимость, например:
Pr7 = (Pr4 - Pr2) * 9 / Pr1;
Если изменилось Pr4, Pr2, Pr1 - выполнить расчет Pr7
1.1 опционально должна быть возможность отключения алгоритма вычисления
2. Формулы необходимо хранить в отдельном классе (сборке)
3. Некоторые свойства могут изменяться третьими лицами (например некий поток опрашиваюий состояние регистра и записывающий это в Foo.Pr1)

Решение:
Алгоритм расчет
static class Alg{
	public static float Compute(float v1){
		return v1 + 1;
	}
}

исходных класс
class Foo{
	public float Pr1{get;set;}
	public float Pr2{get;set;}
}

Вариант 1

class Foo : INotifyPropertyChanged{
	private float _pr1;
	
	public float Pr1{
		get{
			return _pr1;
		}
		set{
			_pr1 = value;
			Pr2 = Alg.Compute(_pr1);
		}
	}
	public float Pr2{ get; set; }
	
	// INotifyPropertyChanged
	...
}
+удобно сопровождать, всегда видно от кого кто зависит
+п. 3 задания решается автоматически
-при использовании MVVM если Foo это модель которая биндиться на представлении то необходимо дополнить модель 
 интерфейсом INotifyPropertyChanged, что, на мой взгляд, несколько портит концепцию модели (п.3 задания)
-невозможно отключить алгоритм вычисления без использования флагов и пр.
 
Вариант 2

Добавление атрибутов

[Alg("Alg")]
class Foo{
	[Modify("Pr2")]public float Pr1{get;set;}
	[Strategy("Compute", new[] {"Pr1"})]public float Pr2{get;set;}
}
+момент запуска вычислений не зависит от установки свойства, т.е. использовать или нет алгорит решает на модель
+если в первом варианте при использовании MVVM класс нужно было дополнить интерфейсом INotifyPropertyChanged, то 
 тут это пережает в другое место (скорее всего модель формы, которая использует эту модель данных) и там модель формы
 говорит что нужно обновить данные модели данных
+п. 2 задания также решается как выше
-нужно обрабатывать атрибуты, вводить новые классы и пр. сложно в общем, скорее всего использовать рефлексию 
 (для вызова статичного метода алгоритма)
-выглядит громоздко, неудобно сопровождать
 
Вариант 3

Добавить декоратор для класса примерно такой

class FooDecor : Foo, INotifyPropertyChanged {
	
	private readonly Foo inner;
	
	public FooDecor(Foo _inner){
		_inner = inner;
	}
	
	public override float Pr1{
		get{
			return _inner.Pr1;
		}
		set{
			_inner.Pr1 = value;
			_inner.Pr2 = Alg.Compute(_inner.Pr1);
		}
	}
	
	// INotifyPropertyChanged
	...
}

+уровень отвественности исходного класса не изменился (в отличии от верианта 1)
+при использовании MVVM INotifyPropertyChanged не засорил исходную модель
+по сути п. 1.1 задания решается использовать или нет докоратор (включение выключение алгоритма)
-п. 1.1 задания не решается если под выключением алгоритма подразумевать использование декорируемого класса
